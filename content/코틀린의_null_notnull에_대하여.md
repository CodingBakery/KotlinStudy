## Java에서 null을 다루던 방법

레퍼런스 타입 변수는 모두 null 가능성을 가지고 있다.  
NPE를 피하려면,

-   어노테이션을 활용하거나 (<code>@Nullable</code>, <code>@NotNull</code>)
-   null을 아예 사용하지 않아야 한다. (1.8 이후 Optional)

## Kotlin에서 null을 다루는 방법

널 가능성을 **타입 시스템**에 포함시키자!

#### 왜 타입 시스템일까?

-   Java는 강한 타입 체킹 언어.
    -   안전성을 보장하기 위해 정적 타입 검사를 시행
    -   프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 검증  
        = 가능한 한 컴파일 타임에 오류를 발견 (이펙티브 자바)
    -   하지만 선언한 타입 외에도 항상 null 참조를 가질 수 있다.  
        = 타입 시스템이 null을 제대로 다루지 못한다.

참조형 변수가 null을 참조할 수 있다면, 타입 시스템에 포함시켜 컴파일 타임에 알 수 있게 하자.

#### String vs String?

-   실행 시점에 두 타입에 담기는 객체는 같음.
-   ~독립적인 별도의 타입~. String?은 String의 래퍼 타입이 아님.
    -   컴파일 시점에 모든 검사가 완료됨.  
        = 실행 시점의 비용 X
-   (추가) **?는 컴파일러에게 알려주는 힌트 정도.** 
    -   실제 IntelliJ에서 String? 타입의 클래스 정보를 확인하면 String으로 이동.  
    -   확장 함수 정의 시 String?, String에서 모두 사용 가능

### null을 다루는 도구들

-   안전한 호출: <code>?.</code>
-   디폴트 값 지정(elvis): <code>?:</code>
-   안전한 캐스트: <code>as?</code>
-   널 아님 단언: <code>!!</code>
-   <code>let</code> 함수
-   지연된 초기화: <code>lateinit</code>
-   nullable 타입의 확장 함수
-   제너릭
-   플랫폼 타입

### 코틀린의 원시 타입 (중 null과 관련한 내용만)

primitive와 reference 타입의 구분이 없다.
하지만 모든 타입을 객체로 표현한다면 비효율적이므로, 실행 시점에 가장 효율적인 방식으로 표현된다.

래퍼 타입으로의 변환이 필수적인 경우

-   제네릭 클래스를 사용
-   null이 될 수 있는 타입: <code>Int?</code>, <code>Boolean?</code>
