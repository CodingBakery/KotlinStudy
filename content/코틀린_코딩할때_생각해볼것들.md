# 코틀린으로 코딩할때 생각해볼 것들

본 내용은 아래의 참고 자료를 발췌한 것임. 아래 내용들은 이펙티브 코틀린 도서를 참고한 것으로 보임.
 * https://www.charlezz.com/?p=45952
 * https://readystory.tistory.com/202

------------------------------------------------------------
## 상속보다는 Composition (Delegation) 을 사용해야할 때는?

무조건적으로 Composition을 사용하라는 말은 아니다.
다음과 같은 장단점에 의해, Composition을 써야하는 상황에는 상속보단 이를 활용하는 것이 훨씬 좋다.
 * 상세 예제 코드 및 설명이 아래 링크에 잘 기재되어있음
   * https://www.charlezz.com/?p=45952
   * https://readystory.tistory.com/202

상속과 Composition 을 사용할 때를 구분해보자면 다음과 같이 이야기하고 있다.
 * 클래스의 객체가 다른 클래스의 객체가 들어갈 자리에 쓰여야 한다면 상속을 사용해라. (리스코프 치환의 원칙?)
 * 클래스의 객체가 단순히 다른 클래스의 객체를 사용만 해야 한다면 델리게이션을 사용해라.

### 상속의 단점
 * 우리가 일반적으로 공통 로직을 상위 / 추상 클래스에 작성하고 이를 맹목적으로 상속하는 구조를 많이 구현한다.
 * 일단 상속을 받으면, 해당 클래스에 귀속되어 버리게 되며, 모든 것을 가져온다.
   * 상속을 통해 행위를 추출하다보면 많은 함수를 갖는 거대한 BaseXXX 클래스를 만들게 된다.
   * 상속은 클래스의 모든 것을 가져오므로, 불필요한 함수를 갖는 클래스가 되기도 한다.
   * 메서드(함수)의 작동방식을 이해하기 위해 수퍼클래스를 여러번 확인해야 할 수도 있다.

### Composition (Delegation)의 장점
 * 델리게이션은 상속보다는 유연하고 재사용하기 쉽다.
   * 객체는 객체 자신이 처리해야 할 일을 다른 클래스의 인스턴스에게 위임하거나 넘겨버릴 수 있다.
 * 코틀린에서는 By 키워드를 통해 Delegation 에 대한 코드 작성을 매우 간결하게 할 수 있다.
   ```kotlin
   // java style
   class Manager(val worker: Worker) {
     fun work() = worker.work()
     fun takeVacation() = worker.work()  // 매니저가 쉬어도 작업자는 일을 해야하는...
   }

   fun main() {
     val manager = Manager(JavaProgrammer())
     manager.work()	// code with Java
   }
   
   // kotlin style
   class Manager() : Worker by JavaProgrammer()
   ```
 * 객체지향 디자인 패턴의 교과서라 불리는 <GoF의 디자인 패턴> 같은 책이나 <이펙티브 자바> 등 굉장히 유명한 저서에서는 상속(is-a)보다는 델리게이션(has-a)을 사용할 것을 강력하게 추천하고 있음.


------------------------------------------------------------

## 연산 또는 액션을 전달 할 때는 인터페이스 대신 함수 타입을 사용하기
연산 또는 액션을 전달할 때 메서드가 하나만 있는 인터페이스를 정의해서 활용한다. 
이러한 인터페이스는 SAM(Single-Abstract Method)라고 부른다.

이러한 인터페이스를 사용하는 예제코드를 살펴보자

```kotlin
interface OnClick {
  fun onClick(view: View)
}

fun setOnClickListener(listener: OnClick){}

setOnClickListener(object : OnClick {
override fun onClick(view:View){}
})
```

인터페이스 대신 함수타입을 사용하는 코드로 다음과 같이 변경해보자.

```kotlin
fun setOnClickListener(listener: (View) -> Unit) { }
```

함수 타입을 사용하면 다음과 같은 방법으로 파라미터를 전달할 수 있다.
```kotlin
setOnClickListener {} // trailing 람다 표현식
setOnClickListener(fun(view) {}) // 익명 함수 전달
setOnClickListener(::println) // 함수 레퍼런스 전달

// 함수 타입을 구현한 객체로 전달
class ClickListener : (View) -> Unit {
  override fun invoke(view:View) {}
}
setOnClickListener(ClickListener())
```
타입별명(type-aliase)를 사용하는 방법도 있다.

```kotlin
typealias OnClick = (View) -> Unit
fun setOnClickListener(listener:OnClick) {}
```
그렇다면 언제 SAM을 사용해야 할까?
 * 정답: 코틀린이 아닌 다른 언어에서 사용할 클래스를 설계 할 때

일반적인 경우 함수 타입을 사용하는 것이 좋다.


------------------------------------------------------------
## API의 필수적이지 않는 부분을 확장함수로 추출하기
클래스를 설계하다보면 메서드를 멤버로 정의할 지 확장함수로 따로 뺄지 고민하게 된다. 
정답은 없으므로 두가지 방식의 장단점을 명확하게 파악하고 상황에 맞게 사용해야 한다.

 * 확장 함수는 일반적으로 다른 패키지에 위치한다.
 * 같은 이름으로 다른 동작을 하는 확장함수가 있을 경우 위험할 수 있다.
 * 멤버 메서드와 확장함수명이 같으면 멤버 메서드가 우선 순위를 갖는다.
 * 확장 함수는 클래스 위가 아니라 타입 위에 만들어지므로, 클래스 레퍼런스에 나오지 않는다
 * 확장 함수는 실제로 확장하는 클래스를 수정하지 않는다. 정적으로 전달된다.
 * 확장 함수는 가상(virtual)함수가 아니다. 그러므로 파생 클래스에서 오버라이드 할 수 없다. 즉, 상속을 목적으로 설계된 요소는 확장함수로 만들면 안된다.

 > 가상(virtual)함수라는 것은 런타임에 결정된 함수를 말한다. 그렇기 때문에 함수가 호출되기 전에 오버라이드 할 수 있으며 코틀린에서는 open 또는 abstract 키워드를 붙여 가상함수를 만들 수 있다. c++에 익숙하다면 c++에서 사용하는 virtual 키워드와 일맥상통한다는 것을 눈치 챌 수 있다.

확장함수는 우리에게 더 많은 자유와 유연성을 준다. 확장 함수는 상속, 어노테이션 처리 등을 지원하지 않고, 클래스 내부에 없다. 
API의 필수적인 부분은 멤버로 두는 것이 좋지만, 필수적이지 않은 부분은 확장함수로 만드는 것이 여러모로 좋다.

------------------------------------------------------------
## 멤버 확장함수의 사용을 피하라

멤버 확장을 피해야 하는 몇가지 이유

함수 레퍼런스를 지원하지 않음.
암묵적 접근을 할 때 두 리시버 중에 어떤 리시버가 선택될지 혼란스럽다.
```kotlin
class A { 
  val a = 10
}

class B {
  val a = 20
  val b = 30

  fun A.test() = a+b // 여기서 a는 10인가 20인가
}
```

마찬가지로 확장함수가 외부에 있는 다른 클래스를 리시버로 받을 때, 해당 함수가 어떻게 동작하는지 애매모호 하다.
```kotlin
class A { 
    // 생략
}

class B {
  fun A.update() = {} // 누굴 위한 업데이트인가
}
```

일반적으로는 멤버 확장함수 사용은 피하는 것이 좋고, 사용하는 경우 단점을 명확히 인지하자. 그리고 가시성 제한자를 적극 활용하여 외부에 노출되지 않도록 하자.

------------------------------------------------------------
## data 한정자 사용하기
데이터 셋을 전달해야 할 때가 있다. 이때 data 클래스를 사용한다.

data 클래스에는 몇가지 함수가 자동으로 생성된다.

 * toString : 클래스 이름, 모든 프로퍼티 출력 
 * equals : 기본 생성자의 프로퍼티가 같은지 확인
 * hashCode : 비교한 두 객체가 동등하다면 동일한 버킷아이디 반환
 * copy : 기본 생성자 프로퍼티가 같은 새로운 객체로 (얕은)복제를 하며, 프로퍼티를 변경할 수도 있다.
 * componentN(component1, component2 등) : 위치를 기반으로 프로퍼티에 접근한다.

------------------------------------------------------------
## 튜플 대신 데이터 클래스 사용하기
코틀린의 튜플은 Pair와 Triple이 있으며 Serializable을 기반으로 만들어 진다. 
몇가지 케이스를 제외하면 일반적인 상황에서는 이러한 튜플 사용보다는 data 클래스를 사용하는 것이 좋다. 
왜냐하면 Pair 또는 Triple 시 프로퍼티 이름이 없기 때문에 타입만 보고 인지하기 어려울 수 있기 때문이다.

data 클래스를 사용하는 것은 비용이 크지 않으며, 좁은 스코프에서만 사용하고 싶다면 가시성을 제한하면 된다. 
튜플보다 data 클래스가 갖는 장점이 많으니 적극적으로 활용하는 것을 권장한다.